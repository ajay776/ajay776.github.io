{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"Memory management and Performance Optimisation. Let's delve deeper into memory management and performance optimization in Python. 1.1 Memory Management: 1.1.1 Garbage Collection: Memory management in Python involves the allocation and deallocation of memory for objects. Python uses a garbage collector to automatically reclaim memory from objects that are no longer referenced in the program. The primary mechanism is reference counting, where each object keeps track of the number of references pointing to it. When this count drops to zero, the memory occupied by the object is freed. Example: # Creating a list my_list = [1, 2, 3, 4, 5] # Creating another reference to the same list another_reference = my_list # Deleting the original reference del my_list # The list still exists because there is another reference print(another_reference) # Deleting the second reference del another_reference # At this point, the list is no longer referenced and will be garbage collected 1.1.2 Memory Profiling: In more complex scenarios, you may want to profile memory usage to identify potential memory leaks or optimize memory-intensive sections of your code. The memory_profiler module can be used for this purpose. Example: # Example of Memory Profiling from memory_profiler import profile @profile def memory_intensive_function(): # Memory-intensive operations here my_list = [0] * 10**6 result = sum(my_list) return result memory_intensive_function() By using the @profile decorator and running the script with a memory profiler, you can analyze the memory usage of specific functions and lines of code. 1.2 Performance Optimization: 1.1.1 Time Complexity Analysis: Performance optimization involves making your code run faster or use fewer resources. Understanding the time complexity of algorithms and data structures is crucial. The Big O notation is commonly used to describe how the runtime of an algorithm scales with the size of the input. Example: #Example of Time Complexity Analysis # Inefficient way to find the maximum element in a list def find_max_element(lst): max_element = lst[0] for element in lst: if element > max_element: max_element = element return max_element # More efficient way using the built-in max function def optimized_find_max_element(lst): return max(lst) # Analyzing time complexity # Both functions have O(n) time complexity, but the optimized version is more concise # ... 1.1.2 Profiling for Execution Time: To identify performance bottlenecks, you can use profiling tools like cProfile or timeit to measure the execution time of different parts of your code. Example: # Example of Profiling for Execution Time import cProfile def time_critical_function(): # Time-critical operations here my_list = [i for i in range(10**6)] result = sum(my_list) return result # Running cProfile to profile the function cProfile.run('time_critical_function()') The output will provide insights into the time spent in each function and can help you focus on optimizing critical sections. 1.1.3 Cython for Performance: For computationally intensive tasks, you might consider using Cython to write C extensions for Python. Cython allows you to write C-like code that gets compiled to machine code, providing performance improvements. Example: # Example of Using Cython for Performance # my_module.pyx def cythonized_function(): cdef int result = 0 for i in range(10**6): result += i return result # setup.py from setuptools import setup from Cython.Build import cythonize setup( ext_modules = cythonize(\"my_module.pyx\") ) # ... # Profiling the Cythonized function # ... By compiling the Cython code and importing the resulting module, you can achieve performance improvements for specific tasks.","title":"1. Memory management and Performance Optimisation"},{"location":"about/#memory-management-and-performance-optimisation","text":"Let's delve deeper into memory management and performance optimization in Python.","title":"Memory management and Performance Optimisation."},{"location":"about/#11-memory-management","text":"","title":"1.1 Memory Management:"},{"location":"about/#111-garbage-collection","text":"Memory management in Python involves the allocation and deallocation of memory for objects. Python uses a garbage collector to automatically reclaim memory from objects that are no longer referenced in the program. The primary mechanism is reference counting, where each object keeps track of the number of references pointing to it. When this count drops to zero, the memory occupied by the object is freed. Example: # Creating a list my_list = [1, 2, 3, 4, 5] # Creating another reference to the same list another_reference = my_list # Deleting the original reference del my_list # The list still exists because there is another reference print(another_reference) # Deleting the second reference del another_reference # At this point, the list is no longer referenced and will be garbage collected","title":"1.1.1 Garbage Collection:"},{"location":"about/#112-memory-profiling","text":"In more complex scenarios, you may want to profile memory usage to identify potential memory leaks or optimize memory-intensive sections of your code. The memory_profiler module can be used for this purpose. Example: # Example of Memory Profiling from memory_profiler import profile @profile def memory_intensive_function(): # Memory-intensive operations here my_list = [0] * 10**6 result = sum(my_list) return result memory_intensive_function() By using the @profile decorator and running the script with a memory profiler, you can analyze the memory usage of specific functions and lines of code.","title":"1.1.2 Memory Profiling:"},{"location":"about/#12-performance-optimization","text":"","title":"1.2 Performance Optimization:"},{"location":"about/#111-time-complexity-analysis","text":"Performance optimization involves making your code run faster or use fewer resources. Understanding the time complexity of algorithms and data structures is crucial. The Big O notation is commonly used to describe how the runtime of an algorithm scales with the size of the input. Example: #Example of Time Complexity Analysis # Inefficient way to find the maximum element in a list def find_max_element(lst): max_element = lst[0] for element in lst: if element > max_element: max_element = element return max_element # More efficient way using the built-in max function def optimized_find_max_element(lst): return max(lst) # Analyzing time complexity # Both functions have O(n) time complexity, but the optimized version is more concise # ...","title":"1.1.1 Time Complexity Analysis:"},{"location":"about/#112-profiling-for-execution-time","text":"To identify performance bottlenecks, you can use profiling tools like cProfile or timeit to measure the execution time of different parts of your code. Example: # Example of Profiling for Execution Time import cProfile def time_critical_function(): # Time-critical operations here my_list = [i for i in range(10**6)] result = sum(my_list) return result # Running cProfile to profile the function cProfile.run('time_critical_function()') The output will provide insights into the time spent in each function and can help you focus on optimizing critical sections.","title":"1.1.2 Profiling for Execution Time:"},{"location":"about/#113-cython-for-performance","text":"For computationally intensive tasks, you might consider using Cython to write C extensions for Python. Cython allows you to write C-like code that gets compiled to machine code, providing performance improvements. Example: # Example of Using Cython for Performance # my_module.pyx def cythonized_function(): cdef int result = 0 for i in range(10**6): result += i return result # setup.py from setuptools import setup from Cython.Build import cythonize setup( ext_modules = cythonize(\"my_module.pyx\") ) # ... # Profiling the Cythonized function # ... By compiling the Cython code and importing the resulting module, you can achieve performance improvements for specific tasks.","title":"1.1.3 Cython for Performance:"},{"location":"closure_and_decorator/","text":"Closures and Decorators. Let's delve deeper into memory management and performance optimization in Python. 2.1 Closures: Key Concepts: 2.1.1 Function Inside a Function: Closures involve having a function inside another function. The inner function is the closure. 2.1.2 Access to Outer Function's Variables: The inner function has access to the variables of the outer (enclosing) function, even after the outer function has completed execution. 2.1.3 Preservation of State: Closures allow functions to \"remember\" the values of variables in the outer function's scope. Example: def outer_function(x): def inner_function(y): return x + y return inner_function closure_example = outer_function(10) result = closure_example(5) # Output: 15 Here, inner_function is a closure that remembers the value of x from the outer_function . 2.2 Decorators: A decorator is a higher-order function that takes a function and extends or modifies its behavior. It allows you to wrap another function, adding some functionality before or after the original function Key Concepts: 2.2.1 Functions as First-Class Citizens: In Python, functions are first-class citizens, meaning they can be passed as arguments to other functions. 2.2.2 Wrapper Functions: Decorators use wrapper functions to modify the behavior of the original function. 2.2.3 Syntactic Sugar: Python provides a convenient syntax using the @decorator syntax to apply decorators to functions. Example: def my_decorator(func): def wrapper(): print(\"Something is happening before the function is called.\") func() print(\"Something is happening after the function is called.\") return wrapper @my_decorator def say_hello(): print(\"Hello!\") say_hello() Output: Something is happening before the function is called. Hello! Something is happening after the function is called. In this example, my_decorator is a decorator that wraps the say_hello function, adding behavior before and after its execution. 2.3 Combining Closures and Decorators: You can combine closures and decorators for more flexible and reusable code. Closures can be used within decorators to capture and maintain additional state. Example: def multiplier(factor): def decorator(func): def wrapper(*args, **kwargs): result = func(*args, **kwargs) return result * factor return wrapper return decorator @multiplier(2) def square(x): return x * x @multiplier(3) def cube(x): return x * x * x print(square(4)) # Output: 32 print(cube(3)) # Output: 27 Here, multiplier is a closure-based decorator. It takes a factor as an argument and returns a decorator. The returned decorator ( wrapper ) multiplies the result of the original function by the specified factor. Applying @multiplier(2) and @multiplier(3) to square and cube functions demonstrates the flexibility of closures and decorators in creating reusable and adaptable code.","title":"2. Closures and Decorators"},{"location":"closure_and_decorator/#closures-and-decorators","text":"Let's delve deeper into memory management and performance optimization in Python.","title":"Closures and Decorators."},{"location":"closure_and_decorator/#21-closures","text":"Key Concepts:","title":"2.1 Closures:"},{"location":"closure_and_decorator/#211-function-inside-a-function","text":"Closures involve having a function inside another function. The inner function is the closure.","title":"2.1.1 Function Inside a Function:"},{"location":"closure_and_decorator/#212-access-to-outer-functions-variables","text":"The inner function has access to the variables of the outer (enclosing) function, even after the outer function has completed execution.","title":"2.1.2 Access to Outer Function's Variables:"},{"location":"closure_and_decorator/#213-preservation-of-state","text":"Closures allow functions to \"remember\" the values of variables in the outer function's scope. Example: def outer_function(x): def inner_function(y): return x + y return inner_function closure_example = outer_function(10) result = closure_example(5) # Output: 15 Here, inner_function is a closure that remembers the value of x from the outer_function .","title":"2.1.3 Preservation of State:"},{"location":"closure_and_decorator/#22-decorators","text":"A decorator is a higher-order function that takes a function and extends or modifies its behavior. It allows you to wrap another function, adding some functionality before or after the original function Key Concepts:","title":"2.2 Decorators:"},{"location":"closure_and_decorator/#221-functions-as-first-class-citizens","text":"In Python, functions are first-class citizens, meaning they can be passed as arguments to other functions.","title":"2.2.1 Functions as First-Class Citizens:"},{"location":"closure_and_decorator/#222-wrapper-functions","text":"Decorators use wrapper functions to modify the behavior of the original function.","title":"2.2.2 Wrapper Functions:"},{"location":"closure_and_decorator/#223-syntactic-sugar","text":"Python provides a convenient syntax using the @decorator syntax to apply decorators to functions. Example: def my_decorator(func): def wrapper(): print(\"Something is happening before the function is called.\") func() print(\"Something is happening after the function is called.\") return wrapper @my_decorator def say_hello(): print(\"Hello!\") say_hello() Output: Something is happening before the function is called. Hello! Something is happening after the function is called. In this example, my_decorator is a decorator that wraps the say_hello function, adding behavior before and after its execution.","title":"2.2.3 Syntactic Sugar:"},{"location":"closure_and_decorator/#23-combining-closures-and-decorators","text":"You can combine closures and decorators for more flexible and reusable code. Closures can be used within decorators to capture and maintain additional state. Example: def multiplier(factor): def decorator(func): def wrapper(*args, **kwargs): result = func(*args, **kwargs) return result * factor return wrapper return decorator @multiplier(2) def square(x): return x * x @multiplier(3) def cube(x): return x * x * x print(square(4)) # Output: 32 print(cube(3)) # Output: 27 Here, multiplier is a closure-based decorator. It takes a factor as an argument and returns a decorator. The returned decorator ( wrapper ) multiplies the result of the original function by the specified factor. Applying @multiplier(2) and @multiplier(3) to square and cube functions demonstrates the flexibility of closures and decorators in creating reusable and adaptable code.","title":"2.3 Combining Closures and Decorators:"},{"location":"context_manager/","text":"Context Manager: A context manager in Python is an object that is used to set up and tear down resources, such as opening and closing files, acquiring and releasing locks, or connecting and disconnecting from a network. It helps manage resources efficiently by ensuring that they are properly initialized and cleaned up. 3.1 Context Manager with with Statement: Key Concepts: 3.1.1 Entering the Context: When you use the with statement, it calls the __enter__ method of the context manager. This method sets up the necessary resources and returns an object that represents the context. 3.1.2 Executing Code: The indented block of code under the with statement is then executed. This is the part where you work with the acquired resources. 3.1.3 Exiting the Context: After the code block completes (either normally or due to an exception), the __exit__ method of the context manager is called. This method ensures that any necessary cleanup or resource release is performed. Example: Let's take the example of opening and working with a file: # Without using a context manager file = open(\"example.txt\", \"r\") content = file.read() print(content) file.close() # Need to remember to close the file explicitly # Using a context manager (with statement) with open(\"example.txt\", \"r\") as file: content = file.read() print(content) # No need to explicitly close the file; it's taken care of by the context manager In the second example, the with statement ensures that the file is properly opened and closed. If an error occurs during the code block, the __exit__ method is still called to handle any cleanup.","title":"3. Context Manager"},{"location":"context_manager/#context-manager","text":"A context manager in Python is an object that is used to set up and tear down resources, such as opening and closing files, acquiring and releasing locks, or connecting and disconnecting from a network. It helps manage resources efficiently by ensuring that they are properly initialized and cleaned up.","title":"Context Manager:"},{"location":"context_manager/#31-context-manager-with-with-statement","text":"Key Concepts:","title":"3.1 Context Manager with with Statement:"},{"location":"context_manager/#311-entering-the-context","text":"When you use the with statement, it calls the __enter__ method of the context manager. This method sets up the necessary resources and returns an object that represents the context.","title":"3.1.1 Entering the Context:"},{"location":"context_manager/#312-executing-code","text":"The indented block of code under the with statement is then executed. This is the part where you work with the acquired resources.","title":"3.1.2 Executing Code:"},{"location":"context_manager/#313-exiting-the-context","text":"After the code block completes (either normally or due to an exception), the __exit__ method of the context manager is called. This method ensures that any necessary cleanup or resource release is performed. Example: Let's take the example of opening and working with a file: # Without using a context manager file = open(\"example.txt\", \"r\") content = file.read() print(content) file.close() # Need to remember to close the file explicitly # Using a context manager (with statement) with open(\"example.txt\", \"r\") as file: content = file.read() print(content) # No need to explicitly close the file; it's taken care of by the context manager In the second example, the with statement ensures that the file is properly opened and closed. If an error occurs during the code block, the __exit__ method is still called to handle any cleanup.","title":"3.1.3 Exiting the Context:"}]}